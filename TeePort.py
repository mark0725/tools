#coding=utf-8
'''
Created on 2013年7月24日
端口转发器 && 端口代理
@author: http://50vip.com/
'''
import threading
import socket
import thread
import re
import datetime
import time
import os
import traceback
import sys
import string
#print debug information
DEBUG_MODE = False
class SocketProxy(threading.Thread):
    host_l = None
    port_l = None
    host_r = None
    host_r = None
    file_name = None
     
    _serverMap = None
    _clientMap = None
    _counter = 0
    file_write_lock = 0
    def __init__(self, host_l, port_l, host_r, port_r, file_name):
        threading.Thread.__init__(self)
        self.host_l = host_l
        self.port_l = port_l
        self.host_r = host_r
        self.port_r = port_r
        SocketProxy.file_name = file_name
        self._clientMap = {}
        self._serverMap = {}
        self._counter = 1
        self._serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self._serverSocket.bind((self.host_l, self.port_l))
        self._serverSocket.listen(50)
         
        print 'listen the ', self.host_l,':',self.port_l
        thread.start_new_thread(self.arrangeSocketThread, ())
     
    def run(self):
        '''
        accept client connection thread
        '''
        while True:
            #accept the client connect
            client_socket, client_addr = self._serverSocket.accept()
            if client_socket:
                print 'get connection from ', 'client id:', client_socket.__str__(), client_addr
             
            #create connection to server
            try:
                server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                print self.host_r, self.port_r
                server_socket.connect((self.host_r, self.port_r))
                if server_socket:
                    print 'connect to ' + self.host_r + ':' + str(self.port_r)
                 
                #save socket into map, key is generated by code, integer ++
                self._clientMap[str(self._counter)] = client_socket
                self._serverMap[str(self._counter)] = server_socket
                 
                self.clientHanddler(self._counter)
                self._counter  = self._counter + 1
            except Exception:
                print 'server is unreachable, program will exit~'
                if DEBUG_MODE:
                    traceback.print_exc()
                os._exit(0)
             
     
    def arrangeSocketThread(self):
        '''
        arrange socket, release the resource
        '''
        while True:
            #每隔5s清理一次socket，释放冗余资源
            time.sleep(5)
             
            keys = self._serverMap.keys()
            for key in keys:
                if not self._clientMap[key] and self._serverMap[key]:
                    self._serverMap[key].close()
                    del self._serverMap[key]
                    del self._clientMap[key]
                    print 'arrange socket, release the resource'
                elif not self._serverMap[key] and self._clientMap[key]:
                    self._clientMap[key].close()
                    del self._serverMap[key]
                    del self._clientMap[key]
                    print 'arrange socket, release the resource'
                elif not self._serverMap[key] and not self._clientMap[key]:    
                    self._clientMap[key].close()
                    self._serverMap[key].close()
                    del self._serverMap[key]
                    del self._clientMap[key]
                    print 'arrange socket, release the resource'
                     
    def clientHanddler(self, count_id):
        '''
        hand the connection, two thread
        one is forward client message to server
        other is forward server message to client
        '''
        thread.start_new_thread(self.msgFromClient2ServerThread, (count_id, ))
        thread.start_new_thread(self.msgFromServer2ClientThread, (count_id, ))
     
    def msgFromClient2ServerThread(self, count_id):
        '''
        get message from client
        then send it to server
        '''
        while True:
            client_socket = self._clientMap[str(count_id)]
            server_socket = self._serverMap[str(count_id)]
            if client_socket:
                try:
                    #TODO how to package data
                    client_msg = client_socket.recv(1024)
                    if client_msg:
                        '''
                        server exist, send
                        server closed, reconnect, send
                        '''
                        if not server_socket:
                            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                            server_socket.connect((self.host_r, self.port_r))
                            self._serverMap[str(count_id)] = server_socket
                        server_socket.send(client_msg)
                        log_data = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S %f') + '\t' + client_socket.__str__() + '\t' + 'L -> R' + '\t' + client_msg + '\n'
                        SocketProxy.appendToFile(log_data)
                except Exception:
                    print 'receive client message error, client socket is closed, program will skip it~'
                    self._clientMap[str(count_id)] = None
                    if DEBUG_MODE:
                        traceback.print_exc()
                    break
    def msgFromServer2ClientThread(self, count_id): 
        '''
        get message from server
        then send it to the client 
        '''
        while True:
            '''
            server exist, send
            server closed, reconnect
            '''
            client_socket = self._clientMap[str(count_id)]
            server_socket = self._serverMap[str(count_id)]
            if server_socket:
                try:
                    server_msg = server_socket.recv(1024)
                    if server_msg:
                        if client_socket:
                            client_socket.send(server_msg)
                            log_data = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S %f') + '\t' + client_socket.__str__() + '\t' + 'R -> L' + '\t' + server_msg + '\n'
                            SocketProxy.appendToFile(log_data)
                except Exception:
                    print 'receive server message error, server client is closed, program will try connect to server again~'
                    if DEBUG_MODE:
                        traceback.print_exc()
                    try:
                        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        server_socket.connect((self.host_r, self.port_r))
                        self._serverMap[str(count_id)] = server_socket
                        continue
                    except Exception:
                        print 'server is unreachable, program will exit~'
                        if DEBUG_MODE:
                            traceback.print_exc()
                        os._exit(0)
            else:
                try:
                    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    server_socket.connect((self.host_r, self.port_r))
                    self._serverMap[str(count_id)] = server_socket
                    continue
                except Exception:
                    print 'server is unreachable, program will exit~'
                    if DEBUG_MODE:
                        traceback.print_exc()
                    os._exit(0)
    @classmethod   
    def appendToFile(self, data):
        '''
        append data to file pathing with filePath
        '''
        #可以写文件
        if SocketProxy.file_write_lock == 0:
            SocketProxy.file_write_lock = 1 #锁文件
            #if data is not empty, append to file
            if data:
                fileHandler = open(SocketProxy.file_name, 'a')
                fileHandler.write(data)
                fileHandler.close() 
            #释放锁
            SocketProxy.file_write_lock = 0
         
    @classmethod
    def ipFormatChk(self, ip_str):
        '''
        check whether ip is valid
        '''
        if ip_str:
            pattern = r"\b(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b"
            if re.match(pattern, ip_str):
                return True
            else:
                return False
        else:
            return False
def main_func():
     
    PORT_L = None
    HOST_R = None
    PORT_R = None
    FILE_NAME = None
     
    help_str = '''
用法：TeePort.py [-h | -l PORT -r HOST:PORT -d data_file]
无参数 显示帮助文档，和-h参数是一样的
-h 显示命令帮助
-l PORT 监听端口，PORT为端口数值
-r HOST:PORT 监听的服务器地址和端口，HOST为服务器IP，PORT为端口数值
-d data_file 记录文件名称，data_file为文件名称
    '''
    args = sys.argv
    args_len = len(args)
    #帮助
    if (args_len == 2 and args[1] == '-h') or args_len == 1:
        print help_str.decode('UTF-8').encode(sys.getfilesystemencoding())
        os._exit(0)
    else:
        for i in range(args_len):
            try:
                if args[i] == '-l':
                    i = i + 1
                    PORT_L = string.atoi(args[i])
                if args[i] == '-r':
                    i = i + 1
                    HOST_PORT_R = args[i]
                    if len(HOST_PORT_R.split(':')) == 2:
                        PORT_R = string.atoi(HOST_PORT_R.split(':')[1])
                        HOST_R = HOST_PORT_R.split(':')[0]
                        if SocketProxy.ipFormatChk(HOST_R):
                            pass
                        else:
                            HOST_R = '-1'
                            break
                    else:
                        HOST_R = '-2'
                        break
                     
                if args[i] == '-d':
                    i = i + 1
                    FILE_NAME = args[i]
            except Exception:
                PORT_R = '-3'
                break
        #有参数赋值
        if PORT_R == '-1':
            print '输入-d参数值中主机IP格式不正确\n输入命令带参数 -h显示帮助信息'.decode('UTF-8').encode(sys.getfilesystemencoding())
            PORT_R = None
            os._exit(0)
        elif PORT_R == '-2':
            print '输入-d参数值格式不正确，应该为HOST:PORT格式\n输入命令带参数 -h显示帮助信息'.decode('UTF-8').encode(sys.getfilesystemencoding())
            PORT_R = None
            os._exit(0)
        elif PORT_R == '-3':
            print '参数使用错误'.decode('UTF-8').encode(sys.getfilesystemencoding())
            print help_str.decode('UTF-8').encode(sys.getfilesystemencoding())
            PORT_R = None
            os._exit(0)
        else:
            if PORT_L or HOST_R or PORT_R or FILE_NAME:
                #三个参数均赋值
                if PORT_L and HOST_R and PORT_R and FILE_NAME:
                    #parameters id valid, start to work
                    socketProxy = SocketProxy('0.0.0.0', PORT_L, HOST_R, PORT_R, FILE_NAME)
                    socketProxy.start()
                     
                else:
                    print '参数错误： -l,-r,-d必须同时使用，并赋予有效的参数值'.decode('UTF-8').encode(sys.getfilesystemencoding())
                    print help_str.decode('UTF-8').encode(sys.getfilesystemencoding())
                    os._exit(0)
            #三个参数均没有赋值
            else:
                print '参数使用错误'.decode('UTF-8').encode(sys.getfilesystemencoding())
                print help_str.decode('UTF-8').encode(sys.getfilesystemencoding())
                os._exit(0)
if __name__ == '__main__':
    main_func()
    while 1:
        try:
            time.sleep(1)
        except KeyboardInterrupt:
            os._exit(0)
